# -*- coding: utf-8 -*-
"""Causal Impact 1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PDs5BX-Xutl5L6p1QSP4JHxv_gf6jBzD
"""

import streamlit as st
import pandas as pd
from causalimpact import CausalImpact
import matplotlib.pyplot as plt
from io import BytesIO

# Page config
st.set_page_config(page_title="Causal Impact Dashboard", layout="wide")
st.title("üìâ Causal Impact Analysis (Brand Pause)")

# Load data
@st.cache_data
def load_data():
    df = pd.read_csv("dummy_data_ci.csv", parse_dates=["date"])
    return df

df = load_data()

# Validate columns
required_columns = {"date", "market", "conversions", "Paid Search", "Paid Social"}
if not required_columns.issubset(df.columns):
    st.error(f"Missing columns in CSV. Required: {required_columns}")
    st.stop()

# Input: pause date
pause_date = '2024-07-28'

# Input: market selection
markets = df["market"].unique()
selected_market = st.selectbox("üåç Select Market", markets)

# Filter and prepare data
df_m = df[df["market"] == selected_market].copy()
df_m = df_m[["date", "Paid Search", "Paid Social", "conversions"]]
df_m = df_m.set_index("date")

full_weeks = df_m.index.sort_values().unique()
pre_period = [full_weeks.min(), full_weeks[full_weeks < pd.to_datetime(pause_date)].max()]
post_period = [pd.to_datetime(pause_date), full_weeks.max()]

ci_data = df_m[["conversions", "Paid Search", "Paid Social"]]
impact = CausalImpact(ci_data, pre_period, post_period)
results = impact.inferences

# Output
st.subheader("üìä Summary")
st.text(impact.summary())

st.subheader("üìù Report")
st.markdown(f"<pre>{impact.summary(output='report')}</pre>", unsafe_allow_html=True)

st.subheader("üìà Impact Plot - Actual vs. Predicted")
fig, ax = plt.subplots(figsize=(10, 6))

# Plot actual and predicted values
ax.plot(results.index, results['post_cum_y'], label='Actual', color='black')
ax.plot(results.index, results['preds'], label='Predicted (No Pause)', linestyle='--', color='blue')

# Confidence interval
ax.fill_between(results.index, results['preds_lower'], results['preds_upper'], color='blue', alpha=0.2)

# Pause date marker
ax.axvline(pd.to_datetime(pause_date), color='red', linestyle='--', label='Pause Start')

# Labels and formatting
ax.set_title("Causal Impact: Conversions Over Time")
ax.set_xlabel("Date")
ax.set_ylabel("Conversions")
ax.legend()
ax.grid(True)

# Streamlit image render
buf = BytesIO()
fig.savefig(buf, format="png", bbox_inches="tight")
buf.seek(0)
st.image(buf)
buf.close()

st.subheader("üìà Impact Plot - Pointwise Effect Plot")
# üìä Pointwise Effect Plot
fig3, ax3 = plt.subplots(figsize=(10, 6))

ax3.plot(results.index, results['point_effects'], label='Pointwise Effect', color='purple')
ax3.fill_between(results.index, results['point_effects_lower'], results['point_effects_upper'], color='purple', alpha=0.2)
effect_min = results['point_effects_lower'].min()
effect_max = results['point_effects_upper'].max()

# Add some margin
margin = (effect_max - effect_min) * 0.1

ax.set_ylim(effect_min - margin, effect_max + margin)

ax3.axhline(0, color='gray', linestyle='--')
ax3.axvline(pd.to_datetime(pause_date), color='red', linestyle='--', label='Pause Start')

ax3.set_title("Pointwise Effect of Brand Pause")
ax3.set_xlabel("Date")
ax3.set_ylabel("Conversions")
ax3.legend()
ax3.grid(True)

buf3 = BytesIO()
fig3.savefig(buf3, format="png", bbox_inches="tight")
buf3.seek(0)
st.image(buf3)
buf3.close()

st.subheader("üìà Impact Plot - Cumulative Effects Plot")
# üìà Cumulative Effects Plot
fig2, ax2 = plt.subplots(figsize=(10, 6))

ax2.plot(results.index, results['post_cum_effects'], label='Cumulative Effect', color='green')
ax2.fill_between(results.index, results['post_cum_effects_lower'], results['post_cum_effects_upper'], color='green', alpha=0.2)

ax2.axhline(0, color='gray', linestyle='--')
ax2.axvline(pd.to_datetime(pause_date), color='red', linestyle='--', label='Pause Start')

ax2.set_title("Cumulative Effect of Brand Pause")
ax2.set_xlabel("Date")
ax2.set_ylabel("Conversions")
ax2.legend()
ax2.grid(True)

buf2 = BytesIO()
fig2.savefig(buf2, format="png", bbox_inches="tight")
buf2.seek(0)
st.image(buf2)
buf2.close()
